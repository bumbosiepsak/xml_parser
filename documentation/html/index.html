<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>xml_parser: xml_parser: XML parser for embedded solutions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xml_parser
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">xml_parser: XML parser for embedded solutions. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Greetings!</b></p>
<p>I'm sending you some sample code. Actually it's something that works (see description below) and I'll do my best to make it as nice and easy for you as I can.</p>
<p>What I'll more less try to present here is:</p>
<ul>
<li>how I code,</li>
<li>how I design code,</li>
<li>what is my degree of C++ knowledge,</li>
<li>what is my degree of Make knowledge,</li>
<li>what is my approach to software production (documentation, unit tests, used tools, etc.).</li>
</ul>
<hr/>
<h1><a class="anchor" id="description"></a>
Description</h1>
<h2><a class="anchor" id="brief"></a>
Brief</h2>
<p>This sample code is a simple XML parser which I wrote for needs of my past embedded/real time projects.</p>
<p>The rationale behind writing this (although quite common) software was:</p>
<ul>
<li>urgent need for replacement of legacy code (with specific interface),</li>
<li>company's copyright policy and project's guidelines,</li>
<li>relatively high constraints (need for low program memory footprint and strictly deterministic run-time performance),</li>
<li>requirement of high portability, quality and extensibility on demand.</li>
</ul>
<p>During design and implementation phase, few lower-level requirements were formulated:</p>
<ul>
<li>the software shall be easy to use (at the interface level),</li>
<li>the software can utilize all that's offered by C++ and available libraries (metaprogramming) to achieve type safety, modularity and self-optimisation.</li>
<li>the software shall be developed with test-driven approach: by being highly orthogonal and simultaneously unit tested.</li>
</ul>
<h2><a class="anchor" id="introduction"></a>
Introduction</h2>
<p>XML (Extensive Markup Language) is a way of representing some data with its description (metadata) in a textual form. Stand-alone piece of data is called an XML document. It possess a feature of being hierarchical and form a tree structure. Each node of a tree consists of metadata field ("Name"), data field ("Value"), type field ("Type", explained later) and list of node's leafs ("Children").</p>
<p>A piece of software that is able to convert XML document into its corresponding tree is called a parser. And this is what our xml_parser basically does (to be specific: it is a DOM parser).</p>
<p>XML operates on Unicode data, where every character is a so called "code point" (32-bit unsigned integer). Such code points are usually inconvenient to store/transmit and a concept called "encoding" comes to help. Encoding is nothing more, than a strictly defined binary representation of code points. Various standard encodings, like UTF-8 or UTF-16, exist and possess interesting features.</p>
<p>When we want to parse some input data, its encoding needs to be recognized. Then this data might need to be decoded for processing. After that, during tree construction, data might need encoding again (to the desired output format).</p>
<h2><a class="anchor" id="usage"></a>
Usage</h2>
<p>Most basic usage of parser requires few lines of code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="da/dcf/xml__stream__on__string_8h.html">middleware/xml/xml_stream_on_string.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dd/de7/xml__node_8h.html">middleware/xml/xml_node.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dc/d18/xml__parser_8h.html">middleware/xml/xml_parser.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> parsing_hello_world()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>std;</div>
<div class="line">    <span class="keyword">using namespace </span>::middleware::xml;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">string</span> xml(<span class="stringliteral">&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;greeting when=&#39;now&#39;&gt;hello world&lt;/greeting&gt;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    xml_stream_on_string stream(xml); <span class="comment">// Input</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="da/da4/namespacemiddleware_1_1xml.html#acbe96d1078b9b5352e1660f170c9f269">xml_node</a>   root;                  <span class="comment">// Output</span></div>
<div class="line">    <a class="code" href="da/da4/namespacemiddleware_1_1xml.html#a7a2cd65dd2073fe1b20f41862ac695d0">xml_parser</a> parser;                <span class="comment">// Parser</span></div>
<div class="line"></div>
<div class="line">    xml_parser_status status = parser.parse(stream, root);</div>
<div class="line"></div>
<div class="line">    \\ All done! Time to display what we have!</div>
<div class="line"></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;status: &quot;</span> &lt;&lt; status.to_string() &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(status.is_ok());</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span>(xml_node::children_type::const_iterator c  = root.get_children().begin();</div>
<div class="line">                                                    c != root.get_children().end();</div>
<div class="line">                                                  ++c)</div>
<div class="line">        {</div>
<div class="line">            xml_node::value_type <span class="keyword">const</span> &amp;name  = c-&gt;get_name();</div>
<div class="line">            xml_node::value_type <span class="keyword">const</span> &amp;value = c-&gt;get_value();</div>
<div class="line"></div>
<div class="line">            <span class="keywordtype">string</span> type(</div>
<div class="line">                <a class="code" href="da/da4/namespacemiddleware_1_1xml.html#ab9ab68c5992cc42d6da0aa979437569b">is_element</a>(*c)     ? <span class="stringliteral">&quot;element&quot;</span>         :</div>
<div class="line">                <a class="code" href="da/da4/namespacemiddleware_1_1xml.html#a6d0410dc6e703a4af4e09c2532f5fdce">is_attribute</a>(*c)   ? <span class="stringliteral">&quot;attribute&quot;</span>       :</div>
<div class="line">                <a class="code" href="da/da4/namespacemiddleware_1_1xml.html#aa9ba7dc008d360257c3b38b8263f2715">is_valid</a>(*c)       ? <span class="stringliteral">&quot;some valid type&quot;</span> :</div>
<div class="line">                                     <span class="stringliteral">&quot;invalid&quot;</span>);</div>
<div class="line"></div>
<div class="line">            cout &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; type &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This will output something like: </p>
<div class="fragment"><div class="line">status: xml_parser_status::ok</div>
<div class="line">greeting: hello world: element</div>
</div><!-- fragment --><p>In case of more specific needs, there's extra flexibility available:</p>
<ul>
<li>Any stream-like object may serve as XML data source, as long as it's interface contains three member functions: <code>get()</code>, <code>unget()</code> and <code>empty()</code>.</li>
</ul>
<ul>
<li>The xml_node type is actually an <code>xml_node_basic&lt;utf8&gt;</code> (same concept as with good old <code>std::string</code> bein a <code>std::basic_string&lt;char&gt;</code>). The <code>utf8</code> tag serves as a trait for <code>xml_node_basic</code> ("use 8-bit characters") and for the <code>xml_parser</code> itself ("encode output data as UTF-8"). By using different tags, different output encodings may be requested.</li>
</ul>
<ul>
<li>The xml_parser is actually an <code>xml_node_if&lt; xml_parser_basic&lt; xml_encodings, xml_error_printer_silent&gt; &gt;</code>. This means that the default engine (<code>xml_parser_basic</code>) will be used with default input encodings support and a "silent" error printer.</li>
</ul>
<ul>
<li>The <code>xml_encodings</code> is actually a compile-time (MPL-like) <code>ct::vector&lt;utf8&gt;</code>, which means that the parser will accept UTF-8-encoded data. Defining it to be a <code>ct::vector&lt;utf8, utf16&gt;</code> would allow UTF-16 data (at cost of some increase in code size).</li>
</ul>
<ul>
<li>The printer concept allows for customizing of how parser logs its operation. This way the parsing and printing are less coupled. The <code>xml_error_printer_std</code>, for example, prints to standard output.</li>
</ul>
<ul>
<li>STL, as well as MPL style of traits exist. This exposes a metaprogramming interface. For example, the <code>xml_node::children_type</code> equivalent is <code>xml_node_children_type&lt;xml_node&gt;::type</code>.</li>
</ul>
<h2><a class="anchor" id="architecture"></a>
Simplified architecture</h2>
<p>The parsers operation is based on stream processing. The input stream is being decoded into code points. These code points are being processed by the parser, which is (in simple words) a state machine, synchronized with markup used in XML. Distinct XML parts are being extracted (metadata, data, instructions, comments etc.) and, after passing an output stream/encoder, formed into a composite tree structure (XML nodes).</p>
<p>Each node has its type, reflecting its source (root, element, attribute, processing instruction). Please see <code><a class="el" href="d8/d6a/classmiddleware_1_1xml_1_1xml__node__basic.html">middleware::xml::xml_node_basic</a></code> for documentation of the XML node.</p>
<p>Additionally, in first phase of XML stream processing, its encoding is being recognized by a decoder selector. Appriopriate decoding function is being selected and plugged into the decoder.</p>
<p>XML instructions are being processed by a separate (higher level) instruction processor.</p>
<p>The architectural principle is: one functionality, one class (which increases orthogonality of the design).</p>
<h2><a class="anchor" id="key_points"></a>
Key points</h2>
<p>Worth noting:</p>
<ul>
<li>Please see main.cpp for example use.</li>
</ul>
<ul>
<li>The parser engine (<code>xml::impl::xml_parser_basic</code>) does just one pass over XML data. The parsing complexity is O(n), where n is the XML input size. All internal data structures don't require memory re-allocation and allocate it gracefully, what is quite important in embedded/real-time computing.</li>
</ul>
<ul>
<li>The input encoding recognition is done two ways: by peeking first few bytes of data and by reading the XML declaration ("&lt;?xml encoding="utf-8"?&gt;").</li>
</ul>
<ul>
<li>STL is being used under the hood.</li>
</ul>
<ul>
<li>C++ metaprogramming is (not much, but anyway) used. Since my project's guidelines didn't allow usage of Boost, I implemented the (highly desired) equivalent of Boost::MPL myself. It is called <a class="el" href="df/da3/namespacemiddleware_1_1utils_1_1ct.html">middleware::utils::ct</a> (compile time) and can be browsed in includes/middleware/utils/ct. Loose coupling to XML parser is achieved by namespace aliasing. This way original Boost::MPL could be used if needed (without need of touching the core code).</li>
</ul>
<ul>
<li>New encoding types can be added seamlessly - see <a class="el" href="df/d41/encoding__specific__ascii_8h.html" title="Core encoder/decoder for ASCII encoding. ">encoding_specific_ascii.h</a> and <a class="el" href="d3/d6d/encoding__specific__utf8_8h.html" title="Core encoder/decoder for UTF-8 encoding. ">encoding_specific_utf8.h</a>.</li>
</ul>
<ul>
<li>Unit tests are available under path: <code>tests/uoam_tests/gtest/middleware/xml</code>. The project's reality was quite harsh (required usage of 2 unit test frameworks: Googletest + CXX Test; 4 compilers: GCC + MSVC + DIAB + LLVM; 3 platforms: x86 + PowerPC + ARM; 2 build systems: GNU Make + Electric Make, 3 host environments: Linux + Windows + emulated Windows; need for on-target/radiomodule continuous integration), I wrote an extensible continuous integration meta-framework in Make, C++ and Python. It has a plugin-based architecture. It allows adding new toolchains, as well as new components, as plugins. For example it was possible to compile the unit tests-equipped code, upload it to the radiomodule, run tests there and download results with just one keyboard stroke. I can provide its documentation if necessary.</li>
</ul>
<ul>
<li>The code was slightly embellished with Doxygen documentation. What you read now is also a Doxygen-generated page!;)</li>
</ul>
<h2><a class="anchor" id="building"></a>
Building example code</h2>
<p>In order to run the software and unit tests, you need GCC and GNU Make/Cygwin. You also need to update <code>tests/environment/paths_custom.inc</code> to match your configuration.</p>
<p><b>Using pure Make</b>: you can build the working sample from command line (using GCC and GNU Make/Cygwin). After updating <code>tests/environment/paths_custom.inc</code>, please open a command prompt at <code>sample_code_szymon_gutaj</code> location and type (for sample and tests, respectively):</p>
<div class="fragment"><div class="line">mingw32-make all</div>
<div class="line">mingw32-make tests</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Apr 12 2015 18:29:45 for xml_parser by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
